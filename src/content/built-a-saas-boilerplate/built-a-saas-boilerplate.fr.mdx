---
title: "J'ai cr√©√© un SaaS Boilerplate pour les Builders"
description: "Comment et pourquoi j'ai construit un boilerplate SaaS open-source avec Next.js 15, tRPC, Drizzle, Better-Auth et PlateJS. Une base production-ready pour les builders qui veulent shipper vite."
date: "2026-02-06"
tags: ["Next.js", "SaaS", "Boilerplate", "tRPC", "Drizzle", "Open Source", "TypeScript"]
---

√Ä chaque nouveau projet, je passais les deux premi√®res semaines √† faire la m√™me chose : configurer l'authentification, brancher la base de donn√©es, monter un panel admin, ajouter un blog, int√©grer les paiements.

Apr√®s un peu plus de trois ans √† construire des produits (pour des clients, pour moi, pour le fun), j'ai r√©alis√© un truc √©vident : 80% de la base √©tait identique d'un projet √† l'autre. Le seul truc qui changeait, c'√©tait la logique m√©tier.

Alors j'ai arr√™t√© de copier-coller, et j'ai construit un boilerplate. Pas "le starter kit ultime." Juste une fondation solide et opin√©e qui refl√®te comment je construis r√©ellement les choses. C'est open source, et vous pouvez l'utiliser maintenant.

üëâ **[github.com/Bima42/saas-boilerplate](https://github.com/Bima42/saas-boilerplate)**

## Le Probl√®me (Pourquoi √ßa existe)

J'ai shipp√© plusieurs produits ces derni√®res ann√©es. Certains pour des clients, d'autres personnels. √Ä chaque fois, je me retrouvais √† :

1. **Setup l'auth** (sessions, middleware, routes prot√©g√©es)
2. **Configurer la base de donn√©es** (schema, migrations, ORM)
3. **Construire un admin dashboard** (CRUD de contenu, gestion des users)
4. **Ajouter un blog** (√©diteur rich text, SEO, routes publiques)
5. **Int√©grer Stripe** (subscriptions, webhooks)
6. **Dockeriser le tout** (environnements consistants)

Ce boilerplate est fait pour les **builders**, ceux qui veulent valider une id√©e vite, shipper un MVP, et voir si √ßa prend. Pas pour ceux qui veulent optimiser pour 100k utilisateurs simultan√©s d√®s le premier jour.

## La Stack (Ce que j'ai choisi et pourquoi)

Chaque technologie dans cette stack a √©t√© choisie parce que j'ai test√© les alternatives dans des vrais projets, et j'ai gard√© ce qui marchait le mieux.

| Layer | Technologie | Pourquoi |
|:------|:-----------|:----|
| **Framework** | Next.js 15 | App Router, Server Actions, React 19. L'√©cosyst√®me est imbattable. |
| **API** | tRPC v11 | Type safety de bout en bout. Z√©ro doc d'API √† maintenir. |
| **Base de donn√©es** | PostgreSQL + Drizzle ORM | SQL-first, migrations lisibles, pas de magie ORM. |
| **Auth** | Better-Auth | Rien de plus simple √† setup, rien de plus efficace. |
| **√âditeur** | PlateJS | Construit sur Shadcn/UI, l√©ger, complet. |
| **Styling** | Tailwind CSS v4 + Shadcn/UI | Rapide √† construire, design system consistant. |
| **Paiements** | Stripe | Standard de l'industrie. Webhooks pr√©-c√¢bl√©s. |
| **Deploy** | Docker Compose | M√™me environnement partout. Dev = Prod. |

### Le parcours de l'√©diteur

Ce choix m√©rite du contexte parce que j'ai travers√© une vraie √©volution.

Sur mon premier projet (Voltaire), j'ai utilis√© **TipTap** et **Lexical**. Les deux sont puissants, mais le co√ªt de setup √©tait √©lev√©, et les int√©grer dans un design system consistant prenait trop de temps.

Pour la premi√®re version de ce boilerplate, j'ai essay√© **Payload CMS**. C'est un super outil, mais c'√©tait overkill pour ce dont j'avais besoin : un √©diteur de contenu simple et rapide pour des articles de blog. √áa ajoutait de la complexit√© sans assez de retour.

Puis j'ai trouv√© **PlateJS**. Il est construit sur Shadcn/UI, donc il partage le m√™me design system que le reste de l'app. Il stocke le contenu en JSON. Il est l√©ger mais complet (titres, images, blocs de code, liens, tout ce qu'il faut). Il colle parfaitement.

### Pourquoi Better-Auth plut√¥t que NextAuth ?

J'ai test√© NextAuth sur des projets pr√©c√©dents. √áa marche, mais la configuration est verbeuse, et la DX autour du middleware et de la gestion de session m'a toujours sembl√© p√©nible.

Better-Auth est dans le sweet spot : API simple, bas√© sur le middleware, et int√©gration directe avec Drizzle. Un schema, une base de donn√©es, tout au m√™me endroit.

## L'Architecture (Monolithe par choix)

Ce boilerplate est un **monolithe unifi√©**. L'Admin Dashboard, l'application SaaS principale et le Blog public tournent tous dans une seule instance Next.js.

Je sais que les monolithes ne sont pas √† la mode. Microservices, edge functions, serverless : l'industrie pousse vers les architectures distribu√©es. Mais pour un MVP (et honn√™tement, pour la plupart des produits), le monolithe est le bon choix.

Pourquoi :
- **Un repo, un deploy.** Pas de complexit√© d'orchestration.
- **Base de donn√©es et types partag√©s.** Pas de contrats d'API entre services.
- **Facile √† comprendre.** Un nouveau d√©veloppeur peut saisir l'ensemble du syst√®me en un apr√®s-midi.
- On peut toujours splitter plus tard.

```mermaid
flowchart TD
    Client[Next.js Client] --> AppRoutes["App Routes (SaaS)"]
    Client --> AdminRoutes["Admin Routes (CMS)"]
    Client --> BlogRoutes["Blog Routes (Public)"]

    AppRoutes --> tRPC[tRPC API Layer]
    AdminRoutes --> tRPC
    BlogRoutes --> tRPC

    Auth[Better-Auth Middleware] --> tRPC

    tRPC --> Services[Service Layer]
    Services --> Drizzle[Drizzle ORM]
    Drizzle --> Postgres[(PostgreSQL)]
```

### Structure du projet

Voici comment le code est organis√© :

```text
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (admin)/            # Admin Dashboard (prot√©g√©)
‚îÇ   ‚îú‚îÄ‚îÄ (app)/              # Application SaaS principale
‚îÇ   ‚îú‚îÄ‚îÄ api/                # tRPC, Webhooks, endpoints Auth
‚îÇ   ‚îî‚îÄ‚îÄ blog/               # Blog Public (optimis√© SEO)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ admin/              # UI sp√©cifique admin
‚îÇ   ‚îú‚îÄ‚îÄ blog/               # Cards blog, viewers
‚îÇ   ‚îî‚îÄ‚îÄ editor/             # Config & plugins PlateJS
‚îú‚îÄ‚îÄ lib/                    # Clients singleton (S3, Stripe, Auth)
‚îú‚îÄ‚îÄ server/
‚îÇ   ‚îú‚îÄ‚îÄ api/                # tRPC Routers
‚îÇ   ‚îú‚îÄ‚îÄ db/                 # Drizzle Schema & Connexion
‚îÇ   ‚îî‚îÄ‚îÄ services/           # Logique M√©tier
‚îî‚îÄ‚îÄ types/                  # Sch√©mas Zod & types TS partag√©s
```

Les route groups `(admin)`, `(app)` et `blog` sont juste des conventions Next.js. Ils partagent le m√™me backend `server/`. Z√©ro duplication.

## Les patterns que je r√©utilise dans chaque projet

Apr√®s avoir construit plusieurs produits sur cette stack, quelques patterns sont devenus non-n√©gociables pour moi.

### Pattern 1 : Le Service Layer

C'est la d√©cision architecturale la plus importante de ce boilerplate. La r√®gle est simple : **les routers API ne touchent jamais la base de donn√©es directement.**

Les routers sont des controllers fins. Ils valident l'input, v√©rifient l'auth, et appellent un service. C'est tout.

**La mauvaise fa√ßon (ce que je faisais avant) :**

```typescript
// ‚ùå src/server/api/routers/post-router.ts
// Logique DB m√©lang√©e avec la logique API. Difficile √† tester, difficile √† r√©utiliser.
export const postRouter = router({
  getBySlug: publicProcedure
    .input(z.object({ slug: z.string() }))
    .query(async ({ input }) => {
      return db.select().from(posts).where(eq(posts.slug, input.slug));
    }),
});
```

**La bonne fa√ßon (ce que je fais maintenant) :**

```typescript
// ‚úÖ src/server/services/post.ts
// La logique m√©tier est isol√©e, testable, r√©utilisable.
export const postService = {
  getBySlug: async (slug: string) => {
    return db.query.posts.findFirst({
      where: eq(posts.slug, slug),
      with: { author: true, tags: true },
    });
  },

  incrementViews: async (id: number) => {
    await db
      .update(posts)
      .set({ views: sql`${posts.views} + 1` })
      .where(eq(posts.id, id));
  },
};
```

```typescript
// ‚úÖ src/server/api/routers/post-router.ts
// Le router est un controller fin. Propre et lisible.
export const postRouter = router({
  getBySlug: publicProcedure
    .input(z.object({ slug: z.string() }))
    .query(({ input }) => postService.getBySlug(input.slug)),

  incrementViews: publicProcedure
    .input(z.object({ id: z.number() }))
    .mutation(({ input }) => postService.incrementViews(input.id)),
});
```

### Pattern 2 : tRPC pour la type safety

tRPC √©limine une cat√©gorie enti√®re de bugs. Les types circulent depuis votre schema de base de donn√©es, √† travers votre service layer, jusqu'√† vos composants frontend. Si vous renommez un champ dans votre schema, TypeScript va crier partout o√π ce champ est utilis√©.

```typescript
// src/app/(app)/dashboard/page.tsx
'use client';

import { api } from '@/lib/trpc/react';

export default function Dashboard() {
  const { data: posts } = api.post.getAll.useQuery();
  //    ^? { id: number; title: string; slug: string; views: number; ... }[]

  return (
    <ul>
      {posts?.map((post) => (
        <li key={post.id}>{post.title} ({post.views} views)</li>
      ))}
    </ul>
  );
}
```

Si le code compile, le contrat d'API est correct.

### Pattern 3 : Migrations Drizzle

J'ai besoin de faire confiance √† mes migrations de base de donn√©es. Drizzle g√©n√®re des fichiers SQL lisibles que je peux relire, reviewer et versionner.

```typescript
// src/server/db/schema/post-schema.ts
export const posts = pgTable("posts", {
  id: serial("id").primaryKey(),
  slug: text("slug").notNull().unique(),
  title: text("title").notNull(),
  content: jsonb("content"),
  views: integer("views").default(0),
  createdAt: timestamp("created_at").defaultNow(),
});
```

```bash
# G√©n√©rer un fichier de migration depuis les changements de schema
npm run db:generate

# Appliquer la migration √† la base de donn√©es
npm run db:migrate

# Raccourci dev : sync le schema directement (pas de fichier de migration)
npm run db:push
```

Le workflow est toujours le m√™me : modifier le schema, g√©n√©rer, migrer. Pas de surprises.

## Le CMS Custom (Pourquoi j'ai arr√™t√© les outils externes)

La plupart des apps SaaS ont besoin d'une forme de gestion de contenu : articles de blog, changelogs, pages de documentation. Avant, j'allais chercher des outils externes comme Payload CMS ou des headless CMS comme Sanity.

Le probl√®me ? Ils ajoutent de la complexit√©. Un service de plus √† d√©ployer, une API de plus √† int√©grer, un jeu de credentials de plus √† g√©rer. Pour un blog avec 50 articles, ce overhead n'en vaut pas la peine.

Ma solution : **PlateJS + Postgres**.

```mermaid
flowchart LR
    Editor["PlateJS Editor (Admin)"] -->|JSON| API[tRPC API]
    API -->|Save| DB["Postgres (colonne jsonb)"]
    DB -->|Fetch| Viewer["PlateJS Viewer (Blog)"]
    Viewer -->|Render| Public[Page Blog Publique]
```

Le contenu est stock√© en JSON directement dans la colonne `content` de la table `posts`. Pas de service externe. Pas de webhooks. Pas de probl√®mes de synchronisation.

## D√©ploiement (Docker Compose + Self-Hosting)

L'int√©gralit√© du boilerplate est Dockeris√©e. Un seul `docker-compose.yml` fait tourner l'app Next.js et la base PostgreSQL.

```yaml
# docker-compose.yml (simplifi√©)
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgres://user:pass@db:5432/saas
    depends_on:
      - db

  db:
    image: postgres:16
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: saas

volumes:
  postgres-data:
```

**Pourquoi Docker m√™me en d√©veloppement ?** Parce que "√ßa marche sur ma machine" n'est pas une strat√©gie de d√©ploiement valide. Avec Docker, mon environnement local est identique √† la production. Plus de bugs sp√©cifiques √† l'environnement √† debugger.

### O√π h√©berger

J'utilise personnellement **[Dokploy](https://dokploy.com/)**, un PaaS self-hosted qui donne l'exp√©rience Vercel/Heroku sur votre propre VPS. J'ai √©crit un guide complet sur comment d√©ployer une stack Docker Compose avec Dokploy :

üëâ **[Comment d√©ployer un Docker Compose avec Dokploy](https://tanguypauvret.me/blog/deploy-a-compose-with-dokploy)**

Si vous pr√©f√©rez l'h√©bergement manag√©, **[Railway](https://railway.app/)** est aussi un choix solide. Mais j'aime poss√©der mon infrastructure : pas de factures surprises, pas de vendor lock-in, contr√¥le total.

## Pour d√©marrer

Le boilerplate est sous **licence MIT** et disponible sur GitHub :

üëâ **[github.com/Bima42/saas-boilerplate](https://github.com/Bima42/saas-boilerplate)**

```bash
git clone https://github.com/Bima42/saas-boilerplate
cd saas-boilerplate
cp .env.example .env
docker compose up -d --build
```

Ouvrez `http://localhost:3000`. C'est live.

J'ai aussi √©crit de la documentation d√©taill√©e pour les humains et les LLMs :
- **[docs/LLM.md](https://github.com/Bima42/saas-boilerplate/blob/main/docs/LLM.md)** : Architecture, patterns et r√®gles de code (donnez √ßa √† Cursor ou Windsurf)
- **[docs/API.md](https://github.com/Bima42/saas-boilerplate/blob/main/docs/API.md)** : Endpoints tRPC et logique d'auth
- **[docs/DB.md](https://github.com/Bima42/saas-boilerplate/blob/main/docs/DB.md)** : Schema, utilisation de Drizzle et workflows de migration

Si vous utilisez ce boilerplate, trouvez un bug ou voulez une feature, ouvrez une issue ou une PR. Je maintiens ce projet parce que je l'utilise moi-m√™me en production. Chaque am√©lioration b√©n√©ficie aussi √† mes propres projets.

Si vous trouvez √ßa utile, une ‚≠ê sur GitHub m'aide √† savoir que ce travail compte pour la communaut√©.
